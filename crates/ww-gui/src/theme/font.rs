//! Embedded 8x8 bitmap font for pixel-perfect text rendering.
//!
//! Each ASCII glyph (32..=126) is stored as 8 bytes, one per row,
//! where each bit in a byte corresponds to a pixel column.
//! The font texture is built once at startup and reused for all text.

use macroquad::prelude::*;

/// Number of printable ASCII glyphs (space through tilde).
const GLYPH_COUNT: usize = 95;
/// Width and height of each glyph in pixels.
const GLYPH_SIZE: usize = 8;
/// Glyphs per row in the font atlas texture.
const ATLAS_COLS: usize = 16;

/// 8x8 bitmap font data. Each glyph is 8 bytes (rows), MSB = leftmost pixel.
/// Covers ASCII 32 (space) through 126 (tilde).
#[rustfmt::skip]
const FONT_DATA: [u8; GLYPH_COUNT * GLYPH_SIZE] = [
    // 32: space
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 33: !
    0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
    // 34: "
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 35: #
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    // 36: $
    0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
    // 37: %
    0xC6, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00,
    // 38: &
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
    // 39: '
    0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 40: (
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
    // 41: )
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
    // 42: *
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // 43: +
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // 44: ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // 45: -
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 46: .
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // 47: /
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    // 48: 0
    0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00,
    // 49: 1
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 50: 2
    0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00,
    // 51: 3
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
    // 52: 4
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
    // 53: 5
    0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // 54: 6
    0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
    // 55: 7
    0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    // 56: 8
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 57: 9
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    // 58: :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
    // 59: ;
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // 60: <
    0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
    // 61: =
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // 62: >
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
    // 63: ?
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // 64: @
    0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00,
    // 65: A
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // 66: B
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00,
    // 67: C
    0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
    // 68: D
    0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
    // 69: E
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
    // 70: F
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00,
    // 71: G
    0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00,
    // 72: H
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
    // 73: I
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 74: J
    0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00,
    // 75: K
    0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
    // 76: L
    0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00,
    // 77: M
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00,
    // 78: N
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
    // 79: O
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 80: P
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    // 81: Q
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
    // 82: R
    0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00,
    // 83: S
    0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00,
    // 84: T
    0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 85: U
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 86: V
    0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
    // 87: W
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    // 88: X
    0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
    // 89: Y
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00,
    // 90: Z
    0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00,
    // 91: [
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
    // 92: backslash
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
    // 93: ]
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
    // 94: ^
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // 95: _
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    // 96: `
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 97: a
    0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
    // 98: b
    0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00,
    // 99: c
    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
    // 100: d
    0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
    // 101: e
    0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 102: f
    0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00,
    // 103: g
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x78,
    // 104: h
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00,
    // 105: i
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 106: j
    0x06, 0x00, 0x0E, 0x06, 0x06, 0x66, 0x66, 0x3C,
    // 107: k
    0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
    // 108: l
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 109: m
    0x00, 0x00, 0xCC, 0xFE, 0xD6, 0xD6, 0xC6, 0x00,
    // 110: n
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00,
    // 111: o
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 112: p
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0,
    // 113: q
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
    // 114: r
    0x00, 0x00, 0xDC, 0x76, 0x60, 0x60, 0xF0, 0x00,
    // 115: s
    0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
    // 116: t
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,
    // 117: u
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
    // 118: v
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    // 119: w
    0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00,
    // 120: x
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
    // 121: y
    0x00, 0x00, 0xC6, 0xC6, 0xCE, 0x76, 0x06, 0x7C,
    // 122: z
    0x00, 0x00, 0xFE, 0x8C, 0x18, 0x32, 0xFE, 0x00,
    // 123: {
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
    // 124: |
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // 125: }
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,
    // 126: ~
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Built font atlas texture. Created once via [`build_font_texture`].
pub struct PixelFont {
    /// The atlas texture containing all glyphs.
    pub texture: Texture2D,
}

/// Build the font atlas texture from the embedded bitmap data.
///
/// Call this once at startup. The returned texture is used by [`draw_pixel_text`].
pub fn build_font_texture() -> PixelFont {
    let atlas_rows = GLYPH_COUNT.div_ceil(ATLAS_COLS);
    let tex_w = ATLAS_COLS * GLYPH_SIZE;
    let tex_h = atlas_rows * GLYPH_SIZE;
    let mut pixels = vec![0u8; tex_w * tex_h * 4];

    for glyph_idx in 0..GLYPH_COUNT {
        let col = glyph_idx % ATLAS_COLS;
        let row = glyph_idx / ATLAS_COLS;
        let base_x = col * GLYPH_SIZE;
        let base_y = row * GLYPH_SIZE;

        for py in 0..GLYPH_SIZE {
            let byte = FONT_DATA[glyph_idx * GLYPH_SIZE + py];
            for px in 0..GLYPH_SIZE {
                let bit = (byte >> (7 - px)) & 1;
                let idx = ((base_y + py) * tex_w + base_x + px) * 4;
                if bit == 1 {
                    pixels[idx] = 255; // R
                    pixels[idx + 1] = 255; // G
                    pixels[idx + 2] = 255; // B
                    pixels[idx + 3] = 255; // A
                } else {
                    pixels[idx + 3] = 0; // transparent
                }
            }
        }
    }

    let texture = Texture2D::from_rgba8(tex_w as u16, tex_h as u16, &pixels);
    texture.set_filter(FilterMode::Nearest);
    PixelFont { texture }
}

/// Draw text using the pixel font at the given canvas position.
pub fn draw_pixel_text(font: &PixelFont, text: &str, x: f32, y: f32, color: Color) {
    let glyph_w = GLYPH_SIZE as f32;
    let glyph_h = GLYPH_SIZE as f32;

    for (i, ch) in text.chars().enumerate() {
        let code = ch as u32;
        if !(32..=126).contains(&code) {
            continue;
        }
        let glyph_idx = (code - 32) as usize;
        let col = glyph_idx % ATLAS_COLS;
        let row = glyph_idx / ATLAS_COLS;

        let src_x = (col * GLYPH_SIZE) as f32;
        let src_y = (row * GLYPH_SIZE) as f32;

        draw_texture_ex(
            &font.texture,
            x + i as f32 * glyph_w,
            y,
            color,
            DrawTextureParams {
                dest_size: Some(vec2(glyph_w, glyph_h)),
                source: Some(Rect::new(
                    src_x,
                    src_y,
                    GLYPH_SIZE as f32,
                    GLYPH_SIZE as f32,
                )),
                ..Default::default()
            },
        );
    }
}

/// Measure the width in pixels of a text string at scale 1.
pub fn measure_text_width(text: &str) -> f32 {
    text.len() as f32 * GLYPH_SIZE as f32
}
